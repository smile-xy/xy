<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>数据结构</title>
</head>

<script>
    //TODO:TODO:TODO: 第三章 栈
    function Stack() {

        let items = [];

        // 添加元素
        this.push = (element) => {
            items.push(element);
        }

        // 移除元素
        this.pop = () => items.pop();

        // 查看栈顶的元素
        this.peek = () => items[items.length - 1];

        // 检查栈是否为空
        this.isEmpty = () => items.length === 0;

        // 栈长度
        this.size = () => items.length;

        // 栈清空
        this.clear = () => {
            items = [];
        }

        // 打印
        this.print = () => {
            console.log(items.toString());
        }

        // 返回数组
        this.printArr = () => items;
    }
    // let stack = new Stack();
    // console.log('Is empty: ' + stack.isEmpty());
    // stack.push(5);
    // stack.push(8);
    // console.log(stack.peek());
    // stack.push(10);
    // stack.push(15);
    // console.log(stack.peek());
    // stack.pop();
    // console.log(stack.peek());


    //TODO: 用栈解决十进制转二进制
    function divideBy2(decNumber) {

        var remStack = new Stack(),
            rem,
            binaryString = '';

        while (decNumber > 0) {
            rem = Math.floor(decNumber % 2);
            remStack.push(rem);
            decNumber = Math.floor(decNumber / 2);
        }

        while (!remStack.isEmpty()) {
            binaryString += remStack.pop().toString();
        }

        return binaryString;
    }
    // console.log(divideBy2(233));
    // console.log(divideBy2(232133));
    // console.log(divideBy2(3));


    //TODO: 用栈解决十进制转任意进制
    function baseConverter(decNumber, base) {

        var remStack = new Stack(),
            rem,
            baseString = '',
            digits = '0123456789ABCDEF';

        while (decNumber > 0) {
            rem = Math.floor(decNumber % base);
            remStack.push(rem);
            decNumber = Math.floor(decNumber / base);
        }

        while (!remStack.isEmpty()) {
            baseString += digits[remStack.pop()];
        }

        return baseString;
    }
    // console.log(baseConverter(2233, 16));
    // console.log(baseConverter(2233, 8));
    // console.log(baseConverter(2233, 2));


    //TODO: 用栈解决平衡括号
    function BalanceBrackets(str) {
        var arr = str.split(''),
            len = arr.length,
            num = len / 2,
            target = new Stack();

        if (num === parseInt(num)) {

            // 镜像复制arr
            for (let i = len - 1; i >= 0; i--) {
                switch (arr[i]) {
                    case '(':
                        target.push(')');
                        break;
                    case ')':
                        target.push('(');
                        break;
                    case '[':
                        target.push(']');
                        break;
                    case ']':
                        target.push('[');
                        break;
                    case '{':
                        target.push('}');
                        break;
                    case '}':
                        target.push('{');
                        break;
                }
            }

            // 镜像后跟原数组相等 
            for (let i = 0; i < len; i++) {
                if (target.printArr()[i] === arr[i]) {
                    continue;
                } else {
                    return false;
                }
            }
        } else {
            return false;
        }
        return true;
    }
    // var str1 = '{[]()[]}';
    // var str2 = '(({)[}])';
    // var str3 = '{()[]}';
    // console.log(BalanceBrackets(str1));
    // console.log(BalanceBrackets(str2));
    // console.log(BalanceBrackets(str3));


    // TODO 用栈解决汉诺塔 FIXME: 看了源码还不会。。。
    function Hanoi(len, origin, middle, target) {

    }

    var origin = new Stack();
    var middle = new Stack();
    var target = new Stack();
    for (let i = 1; i <= 64; i++) {
        origin.push(i);
    }
    // console.log(Hanoi(origin.size, origin, middle, target)); // 一共需要XXXX步


    //TODO:TODO:TODO: 第四章 队列
    function Queue() {

        let items = [];

        // 添加元素
        this.enqueue = (element) => {
            items.push(element);
        }

        // 移除元素
        this.dequeue = () => items.shift();

        // 查看栈顶的元素
        this.front = () => items[0];

        // 检查栈是否为空
        this.isEmpty = () => items.length === 0;

        // 栈长度
        this.size = () => items.length;

        // 栈清空
        this.clear = () => {
            items = [];
        }

        // 打印
        this.print = () => {
            console.log(items.toString());
        }

        // 返回数组
        this.printArr = () => items;
    }
    // let queue = new Queue();
    // console.log('Is empty: ' + queue.isEmpty());
    // queue.push(5);
    // queue.push(8);
    // console.log(queue.front());
    // queue.push(10);
    // queue.push(15);
    // console.log(queue.front());
    // queue.shift();
    // console.log(queue.front());

    // TODO: 优先队列
    function PriorityQueue() {

        let items = [];

        function QueueElement(element, priority) {
            this.element = element;
            this.priority = priority;
        }

        // 添加元素
        this.enqueue = (element, priority) => {
            let queueElement = new QueueElement(element, priority);
            let added = false;

            for (let i = 0; i < items.length; i++) {
                if (queueElement.priority < items[i].priority) {
                    items.splice(i, 0, queueElement);
                    added = true;
                    break;
                }
            }
            if (!added) {
                items.push(queueElement);
            }
        };

        // 移除元素
        this.dequeue = () => items.shift();

        // 查看栈顶的元素
        this.front = () => items[0];

        // 检查栈是否为空
        this.isEmpty = () => items.length === 0;

        // 栈长度
        this.size = () => items.length;

        // 栈清空
        this.clear = () => {
            items = [];
        }

        // 打印 FIXME:看不懂这个是啥意思
        this.print = () => {
            for (let i = 0; i < items.length; i++) {
                console.log(`${items[i].element} - ${items[i].priority}`);
            }
        }

        // 返回数组
        this.printArr = () => items;
    }
    // let priorityQueue = new PriorityQueue();
    // priorityQueue.enqueue('Jon', 2);
    // priorityQueue.enqueue('Jack', 1);
    // console.log(priorityQueue.front());
    // priorityQueue.enqueue('Cam', 1);
    // priorityQueue.enqueue('Gump', 3);
    // priorityQueue.print();
    // priorityQueue.dequeue();
    // console.log(priorityQueue.front());


    // TODO: 模拟击鼓传花
    function hotPotato(nameList, num) {
        let queue = new Queue();

        for (let i = 0; i < nameList.length; i++) {
            queue.enqueue(nameList[i]);
        }

        let eliminated = '';
        while (queue.size() > 1) {
            for (var i = 0; i < num; i++) {
                queue.enqueue(queue.dequeue());
            }
            eliminated = queue.dequeue();
            console.log('第' + (nameList.length - queue.size()) + '轮 ' + eliminated + '淘汰');
        }
        return queue.dequeue();
    }
    let names = ['John', 'Jack', 'Camila', 'Ingrid', 'Carl'];
    let winner = hotPotato(names, 515);
    // console.log('The winner is ' + winner);


    //TODO:TODO:TODO: 第五章 链表
    function LinkedList() {
        let Node = function (element) {
            this.element = element;
            this.next = null;
        };

        let length = 0;
        let head = null;

        this.append = function (element) {

            let node = new Node(element),
                current;

            if (head === null) {
                head = node;
            } else {
                current = head;
            }
        };
        this.insert = function (position, element) { };
        this.removeAt = function (position) { };
        this.remove = function (element) { };
        this.indexIf = function (element) { };
        this.isEmpty = function () { };
        this.size = function () { };
        this.getHead = function () { };
        this.toString = function () { };
        this.print = function () { };
    };

</script>

<body>
</body>

</html>